# 0. 

该课程讲述了现代计算机图形学中的核心要素，[原课程](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)来自UC Santa Barbara闫令琪教授。
**个人理解的图形学：**
在计算机上设计虚拟的3D模型，并将其渲染成图像（视频），得到具有高度真实性的效果（或者其他期望的效果）。
这个过程可以认为包括两部分：
1. 设计几何模型及其随时间的动画
(4. Geometry & 6. Animation)
2. 将模型渲染成图像
(两种路线，一种是光栅化 2. Rasterization & 3. Shading；另一种是光线追踪 5. Ray tracing)


# 1. Transformation 变换

## 1.1 Basics

缩放、旋转等变换都可以用矩阵乘法表示，为了使平移变换也能用矩阵乘法表示，引入齐次坐标：
对于二维空间，(x, y, 1)表示其中的点，(ax, ay, a)（对任意a>0）表示的是同一个点(x, y, 1)；(x, y, 0)表示其中的向量（其他维度的空间也一样）。
可以验证，根据上述定义：
* 点 - 点 = 向量
* 向量 +/- 向量 = 向量
* 点 +/- 向量 = 点
......

## 1.2 Transformation in Graphics

### 1.2.1 Model transformation 模型变换

对三维空间中的物体进行缩放、旋转、平移等各种变换。

### 1.2.2 View transformation 视图变换

定义相机坐标系，将世界坐标系中的物体变换到相机坐标系中。

### 1.2.3 Projection transformation 投影变换

#### Orthogonal projection 正交投影
1. **物理意义**
相当于直接保留三维物体在相机坐标系中的(x, y)坐标到成像平面上，去掉z轴；无”近大远小“现像。
2. **操作方法** 
将三维空间中的长方体区域变换到$[-1, 1]^3$的标准立方体区域。

#### Perspective projection 透视投影
1. **物理意义**
体现了”近大远小“的原则，投影结果更具有真实感。
2. **操作方法**
先将三维空间中的四棱台区域（图形学管线中称为frustum）变换到长方体区域，再应用正交投影变换到$[-1, 1]^3$的标准立方体区域。


# 2. Rasterization 光栅化

光栅化就是将成像平面上的物体以离散化的像素表示。
三角形具有”同一个三角形内部和边缘上的点都位于同一平面“的优良性质，因此在图形学应用中常被视为基本单元。我们也以三角形为例，考虑光栅化中的问题。

## 2.1 Rasterizing a Triangle

在成像时每个像素覆盖的方格区域只能显示一种颜色，通常由像素方格的中心点位置决定。
因此在光栅化一个三角形的过程中，核心步骤就是判断每个像素方格的中心位置是否在三角形内。

### 2.1.1 Inside function

**点O在三角形ABC内部的条件**
向量组$(OB \times AB, OC \times BC, OA \times CA)$（$\times$表示向量叉积）具有相同的方向（三角形边缘上的情况可根据实际应用自行定义）。

### 2.1.2 Anti-aliasing 反走样

由于成像分辨率不足导致的锯齿化现象称为aliasing，即为信号理论中采样频率不足导致的信号失真。
根据信号理论，对信号先进行低通滤波（模糊）后采样可以解决该问题。这是因为时域上的采样对应频域上的频谱复制，时域上的采样频率越低则频域上频谱复制的越密集，产生交叠导致信号失真；进行低通滤波后，频谱宽度变窄，经过密集复制后交叠的概率降低了。

#### Multi-sample anti-aliasing (MSAA)
1. **操作方法**
对每个像素方格，取其中（均匀分布）的若干个采样点，判断每个点是否位于三角形内部，将这些结果取平均值作为该像素点位于三角形内部的置信度。
2.  **物理意义**
个人理解，MSAA相当于对一个高分辨率的信号（由采样点构成）先做模糊（取均值），得到像素值（采样）。
其中采样的步骤是比较隐式的。

## 2.2 Rasterizing Objects

当有多个物体需要成像时，必须基于深度判断遮挡的情况，这个步骤称为深度测试。

### 2.2.1 Z-Buffer 深度缓存算法

1. **核心思想**
只考虑最前面的物体，因此不需要O(N log N)的排序，只需要一直保留最小值，复杂度为O(N)。
2. **操作方法**
```
# 为每个像素点初始化一个（无穷大）的z值
Z[:] = inf
# 循环遍历每个三角形
for obj in objects:
    # 光栅化该三角形，因此循环遍历每个像素
    for p in P:
        if inside(p, obj):
            # 获取当前三角形在该点的深度值，判断深度缓存是否需要更新
            Z[p] = min(Z[p], obj[p]['z'])
 return Z
```


# 3. Shading 着色

## 3.1 Blinn-Phong Reflectance Model

以物体表面的shading point为基本单元，考虑从该点反射出的光线情况，有以下几个要素：
* **表面法向量n**（我们认为shading point是一小片有面积的单位区域）
* **光线入射方向l**
* **观察方向v**
（上述方向均为单位向量）

通常反射出的光线由漫反射项、高光项和环境光项三部分组成：
$L = L_d + L_s + L_a$

### 3.1.1 Diffuse (Lambertian) term 漫反射项

#### 到达Shading point的光
空间中一个点光源向四面八方发射出的光线，可以认为在每一时刻都到达一个以点光源为中心的球面。
因此，球面上某点接收到的光照强度与球面积成反比。
半径为单位长度的球面上，每个点接收到光照强度为I，那么距离光源为r的shading point接收到光照强度为$I/r^2$ .

#### Shading point吸收到的光
$L = (I/r^2) max(0, n \cdot l)$ .
入射方向和表面法向量夹角越小，吸收到的光越多；光线垂直入射时能被最大程度吸收。

#### Shading point反射的光
物体表面会基于自身颜色，反射一部分光，吸收掉另一部分
$L_d = K_d (I/r^2) max(0, n \cdot l)$ .
在漫反射情况下，shading point向各个方向反射出的光照是一样的，因此与观察方向无关。对同一个点，从任意视角观察到的颜色都是一样的。

### 3.1.2 Specular term 高光项

在这部分将模型简化，只考虑到达shading point的光和shading point反射的光，吸收的情况省略掉（实际与前面漫反射项一致）。
高光项近似于镜面反射，当观察方向与镜面反射方向接近时容易看到高光
但是，给定光线入射方向和法线方向，计算反射方向的表达是比较繁琐的；相比之下，计算入射方向与观察方向的角平分线方向（半程向量），并考察它与法线方向的接近程度也能起到相同的作用，且更容易计算：
**半程向量** $h = \frac{l + v}{\| l + v \|}$ .
从观察方向v看到的高光项亮度为
$L_s = K_s (I/r^2) max(0, n \cdot h)^p$ .
指数p越大，高光项越接近于严格的镜面反射。

### 3.1.3 Ambient term 环境光项

一个大胆的假设：对任意shading point从任意方向观察到的环境光项是相同的！
$L_a = K_a I_a$ .

## 3.2 Shading Frequency

### 3.2.1 Flat shading

对于每一个（三角形）平面，基于该平面的法线方向计算反射光，整个平面渲染成同一种亮度。

### 3.2.2 Gouraud shading

对于每一个（三角形）平面的各个顶点，基于顶点的法线方向计算顶点处的反射光，然后基于顶点亮度插值出平面内某个点（或fragment）的渲染亮度。
其中，顶点的法线方向可以通过对其邻接的各个平面法线方向进行加权平均得到。

### 3.2.3 Phong shading

对于每一个（三角形）平面，基于顶点的法线方向出指出平面内某个点的法线方向，然后基于该点的法线方向计算该点（或fragment）的渲染亮度。

## 3.3 Graphics Pipeline 实时渲染管线

基本的实时渲染管线由以下步骤构成：
1. 经过 model - view - projection 变换将三角形的顶点投影到屏幕上
2. 三角形光栅化（包括 anti-aliasing 和 Z-buffer）
3. 三角形着色

其中，对每个点（或fragment）进行着色处理的代码被称为shader。

## 3.4 Interpolation 插值

插值是计算机图形学中常用的重要基础技术，用于从索引为离散值的计算机存储数据中查询任意连续值索引的数据。

### 3.4.1 Baycentric coordinates 重心坐标

在一条线段上，给定两个端点的（属性）值，插值得到线段上任意一点的（属性）值是很容易的。接下来我们考虑平面上，特别地，一个三角形内部任意点的（属性）值如何通过插值得到。

空间中一个三角形三个顶点坐标为A, B, C,, 三角形所在平面上任意一点v的坐标可表示为：
$v = \alpha A + \beta B + \gamma C$ .
其中，$\alpha + \beta + \gamma = 1$ .
这一约束确保了点v在三角形所在平面上。
特别地，当点v在三角形内部时，$\alpha, \beta, \gamma \geq 0$
$<\alpha, \beta, \gamma>$ 被称为点v的重心坐标。
至此，给定三个顶点的任意属性值f，利用重心坐标即可插值出点v的属性值f：
$f_v = \alpha f_A + \beta f_B + \gamma f_C$ .
这种插值方式可用于各种属性值，包括前面Gouraud shading中的渲染亮度、Phong shading中的法线方向，以及后面要讲的纹理映射。

## 3.5 Texture Mapping 纹理映射

纹理可以认为是一张二维图像；空间中的三维物体的表面也是二维的。
因此，可以建立物体表面上的点到纹理图上的点的映射关系，称为纹理映射。
例如，根据定义好的纹理映射关系，物体表面上的点a映射到纹理图上的点<u, v>，那么纹理图上点<u, v>的纹理颜色T(u,v)即可用来贴到点a上（通常用作着色中漫反射项的$K_d$)，这一过程称为纹理查询 (texture query)。
这样的纹理映射关系，通常需要设计师精心设计。

### 3.5.1 Point query 点查询

假设纹理图像中每个像素的坐标都是整数，但纹理查询得到的点<u, v>未必是整数，此时可通过（双线性）插值的方法得到T(u,v)。

距离相机较近的物体，经过光栅化后在屏幕上一个像素方格的区域映射到纹理图像上，通常是不足一个像素方格的极小区域；换句话说，此时纹理图像分辨率偏低。这种情况可以直接通过双线性插值取近似值，作为纹理查询的结果。

### 3.5.2 Range query 范围查询

而距离相机较远的物体，经过光栅化后在屏幕上一个像素方格的区域映射到纹理图像上，通常会覆盖多个像素放个连成的一大片区域；换句话说，此时纹理图像分辨率偏高。这种情况下，如果仍然基于点进行查询，就会出现欠采样导致的aliasing（与光栅化中的锯齿现象原理相同）。

可以在屏幕上的每个像素方格内增加采样点（提高采样频率）以去除aliasing，但这样开销太大。更好的方法是用范围查询替代点查询，直接查询被覆盖的一大片纹理图像区域的像素均值。

#### Mip-Map

Mip-Map是一种计算和存储开销都很低的范围查询方式。具体做法是提前对原始的纹理图像取 $2 \times, 4 \times, ...$ 的下采样，得到多层的Mip-Map（类似于计算机视觉中的图像金字塔）。
存储所有这些下采样的图像**只带来 $\frac{1}{3}$ 的额外存储开销**。

**如何计算覆盖区域的范围？**
可以将待查询的屏幕像素方格及其周围4个方格映射到纹理图像上，从而近似计算 $(<\frac{du}{dx}, \frac{dv}{dx}>, <\frac{du}{dy}, \frac{dv}{dy}>)$ .
根据覆盖区域的范围大小，从Mip-Map对应的层取值即可。
可以看出，**Mip-Map只适合查询近似于正方形的区域**。

#### Variants of Mip-Map
* **Trilinear sampling（三线性插值）：**
如果覆盖区域的范围大小无法刚好对应到Mip-Map的整数层，可以先从前后两层分别取值，然后插值。三线性插值使画面颜色具备更好的连续性。
* **Anisotropic filtering（各向异性过滤）：**
用于解决Mip-Map只适合查询正方形区域的问题。具体做法是在Mip-Map基础上引入单独对长/宽进行下采样的图像，以查询不同长宽比的矩形区域。

### 3.5.3 Applications of textures

#### Environment mapping 环境贴图
场景中的某一点会接收到来自场景各个方向的光，光的亮度（颜色）取决于该方向的场景物体。特别地，当物体表面足够光滑，反射出的光就会呈现出场景的镜像。
可以用环境贴图实现上述效果。具体做法是存储一个球面接收到的来自场景各个方向的环境光，形成球面环境贴图 (spherical environment mapping)，之后可以根据给定方向取环境贴图上的对应区域。注意这里环境贴图只和方向相关，不考虑距离远近，是一种近似。
将球面存储在平面图像上会出现形变，可以用球体的外接立方体表面代替球面(cube mapping)，减少形变；但这样需要额外计算给定方向与立方体表面的交点位置。

#### Bump/Noraml mapping 凹凸/法线贴图
对于形状规则但表面凹凸变化的物体（e.g.，橘子：表面凹凸变化的球体），用大量三角形表示该物体的表面并不合算。可以用规则形状搭配凹凸贴图表示。
凹凸贴图可以表示物体表面每一点沿原始（形状规则的）表面上该点法线方向的高度起伏；可以通过差分计算该点梯度方向，从而得到与梯度方向垂直的法线方向，作为该点新的法线方向。
也可以直接用贴图表示法线方向变化，称为法线贴图。
凹凸/法线贴图可以通过影响着色来模拟表面凹凸的效果，但忽略了表面凹凸区域相互遮挡光线形成的阴影，是一种近似。

#### Displacement mapping 位移贴图
直接用贴图表示表面各个位置上三角形顶点的位移。
可以实现表面凹凸区域相互遮挡光线形成的阴影，比凹凸/法线贴图更真实，但要求三角形足够密集。


# 4. Geometry 几何

## 4.1 Representations of Geometry 几何表示

几何表示主要分为隐式和显式，两者区别在于能否直接从表示得到被表示的物体上的点集。

### 4.1.1 Implicit representation 

从隐式表示无法直接得到被表示的物体上的点集。

#### Algebraic surface
$f(x, y, z) = 0$ .
给定点<x, y, z>，容易判断该点是否在被表示的平面上；但很难枚举出平面上的点集。

#### Constructive solid geometry
定义几何形体之间的并、交、差等运算，通过规则几何形体之间的运算组合得到复杂形体。

#### Signed distance function (SDF)
$SDF(x, y, z)$ 表征的是空间中任一点<x, y, z>到被表示的物体表面的最短距离。特别地，距离的正/负可以表征该点在（封闭的）物体表面的外部/内部。
基于SDF的表示很容易插值出运动过程中的物体形态；即，给定两个时刻的物体SDF表示，通过插值即可得到两个时刻之间任一时刻的物体SDF表示。

#### Level set 水平集
水平集的物理意义与SDF相同，但直接用阵列存储各个均匀采样点到被表示的物体表面的距离数据。
相比表达式形式的algebraic surface和SDF，存储开销变大，但能表示更复杂的几何形状。

#### Fractal 分形
一种类似于递归的结构，物体上的子区域会重复物体的形状，如此往复。
e.g.，六边形雪花的每一边还是雪花形状，不断重复。

### 4.1.2 Explicit representation 

从显式表示可以直接得到被表示的物体上的点集。

#### Parameter mapping
$f: R^2 \rightarrow R^3; <u, v> \rightarrow <x, y, z>$ .
通过遍历给定定义域上的所有点<u, v>，可得到所有点<x, y, z> .

#### Point cloud 点云
直接表示物体表面的点集，对几何形状表示的准确性取决于点集的疏密程度。通常由3D扫描直接得到。

#### Polygon mesh
用大量多边形（通常是三角形）表示物体表面，图形学中最常用的表示形式。

## 4.2 Curve 曲线

着重介绍贝塞尔曲线，从物理意义和代数表示两个角度分析，分析方法可推广到对其他曲线类型的研究。

### 4.2.1 Bezier curve 贝塞尔曲线

1. **物理意义**
n阶贝塞尔曲线的物理意义由**de Casteljau算法**定义：
给定n+1个有序的控制点 $\{ b_0, b_1, ..., b_n \}$，形成的贝塞尔曲线被看作一条从时间上t=0到t=1的运动轨迹，其中t=0时位于$b_0$，t=1时位于$b_n$。在(0, 1)之间的任一时刻t运动到的位置通过如下方式计算：
首先，取线段 $(b_0, b_1)$ 上的插值点 $b_0^1 = (1-t) \cdot b_0 + t \cdot b_1$；类似地，在$(b_1, b_2), ..., (b_{n-1}, b_n)$ 上取插值点$b_1^1, ..., b_{n-1}^1$ .
之后，在点集 $\{ b_0^1, ..., b_{n-1}^1 \}$ 上重复上述步骤，得到新的一批点集；如此往复，直到点集中剩下一个点，就是轨迹在时刻t运动到的位置。
可以看到，1阶贝塞尔曲线就是连接2个控制点的线段。
2. **代数表示**
轨迹在时刻t运动到的位置是控制点位置的线性组合：
$C(t) = \sum_{i=0}^n \tbinom{i}{n} t^i (1-t)^{n-i} b_i$ .
其中，线性组合的系数是著名的Bernstein多项式（即二项式的n阶展开）。

请注意，贝塞尔曲线的定义在三维空间同样适用。基于上述定义可以得出一些贝塞尔曲线的性质：
* 必定从$b_0$开始，到$b_n$终止
* 在$b_0$处的切线方向与$\overrightarrow{b_0 b_1}$一致；在$b_n$处的切线方向与$\overrightarrow{b_{n-1} b_n}$一致
* 整条曲线都位于全体控制点形成的凸包（即包络所有控制点的最小凸多边形/多面体）内
* 对全体控制点做仿射变换相当于对曲线做仿射变换
......

### 4.2.2 Piecewise Bezier curve 分段贝塞尔曲线

当控制点过多时，得到的曲线形状变得很难控制。因此，直接增加控制点并不能很好地表示更复杂的曲线。此时更好的解决方案是分段贝塞尔曲线，即连接在一起的多段低阶贝塞尔曲线（3阶最常用）。

#### Continuity
* **$C^0$ continuity**
上一段曲线的终止点$a_n$和下一段曲线的起始点$b_0$重合即可：$a_n = b_0$ .
* **$C^1$ continuity**
上一段曲线的终止点$a_n$和下一段曲线的起始点$b_0$的切线（一阶导数）方向一致，即$a_{n-1}, a_n(b_0), b_1$共线；一般来说，还要求一阶导数的大小要连续，即$a_n = b_0 = \frac{a_{n-1}+b_1}{2}$ .

类似地，还可以定义更高阶的连续性......

## 4.3 Surfaces 曲面

### 4.3.1 Bezier surface 贝塞尔曲面

1. **物理意义**
贝塞尔曲线的定义很容易推广到贝塞尔曲面：
给点 $m \times n$ 个控制点，以及 $(u, v) \in (0, 1)^2$ . 
控制点视为m组、每组n个，首先在每组的n个点上、基于贝塞尔曲线的定义插值出u的对应点；随后将这m个点视作控制点，基于贝塞尔曲线的定义插值出v的对应点。整体思想与双线性插值类似。

### 4.3.2 Mesh operations

Mesh是图形学中最常用的结构，这里介绍一些针对mesh的常用处理操作。

#### Subdivision (upsampling) 细分
用于增加Mesh的三角形/多边形个数的同时保持整体形状，提高分辨率。
细分通常包括两个步骤：
* 增加新的顶点和边
* 调整顶点位置

下面介绍两种经典算法：
1. **Loop subdivision**
（Loop是人名）
只能处理所有面片都是三角形的mesh .
第一步，对每个原始的三角形，在其三个边上各取一点相互连接，从而将一个三角形分解为四个三角形。
第二步，首先设定新添加的顶点位置。每个新顶点位于一条原始的边AB上，该条边由两个原始的三角形ABC和ABD共享，新顶点的位置设定为：
$\frac{3}{8} \cdot (A+B) + \frac{1}{8} \cdot (C+D)$ .
随后更新原有旧顶点的位置。设该顶点度为n（连接n条边），更新后该定点位置是其原始位置和周围其他旧顶点原始位置的线性组合：
$(1 - n \cdot u) * pos_{original} + u *  \sum_n pos_{neighbor}$ （u为权重值，与n相关）。
2. **Catmull-Clark subdivision**
能够处理任意形状的面片。
第一步，对每个原始面片，在其内部取一点，并连接到原始的边上，从而将一个n边形分解为n个四边形。可以看到，经过一次细分后所有面片都是四边形。
第二步，调整新旧顶点的位置。同样是利用周围点（和顶点本身）的原始位置进行线性组合，不再细述。

#### Simplification (downsampling) 简化
用于减少Mesh的三角形/多边形个数的同时保持整体形状，降低分辨率。
经典算法：
1. **Edge collapse**
核心思想是将原始的一条边坍缩到一个顶点。以二次度量误差为准则，考虑原始的边关联的各个面，最小化坍缩后的顶点到这些面的L2距离之和。实际操作中，对于原始的每条边都计算边坍缩的二次度量误差，每次坍缩掉二次度量误差最小的那条边，同时动态更新受到影响的边的二次度量误差（利用堆的数据结构）。

#### Regularization 正则化
用于使Mesh中的三角形面片都具有类似正三角形的形状，同时保持被表示的物体的整体形状。


# 5. Ray Tracing 光线追踪

## 5.1 Motivations

在光栅化流程中，相当于只考虑光从光源发出后被物体反射一次进入相机的情况，无法处理全局光照（即同时考虑来自光源的光和被其他物体反射的光），渲染结果的质量有限。
以对阴影效果的处理为例。光栅化中有一种近似得到阴影的方法，称为阴影贴图 (shadow mapping). 
其核心思想为：**处在阴影之外的物体，对光源和相机来说都是可见的**。具体操作如下：
1. 从光源观察物体，利用Z-buffer深度缓存算法得到一张深度图 $Z_l$.
2. 从相机观察物体，再次利用Z-buffer算法处理可见/遮挡，得到深度图 $Z_c$.
3. 对 $Z_c$ 上每一点，计算其到光源的距离（深度）和投影位置，对比该深度值和 $Z_l$ 上投影位置的深度值，如果一致，说明该点对光源和相机均可见。对每个点作上述处理，即可得到一张阴影贴图。

阴影贴图被用于大量游戏，但存在缺陷：
* 只能得到硬阴影（点光源），无法得到软阴影（光源有体积）。
* 判断两个浮点数相等非常困难。
* 好的效果依赖于高分辨率的阴影贴图。

## 5.2 Basic ray tracing

光线追踪能够处理全局光照，得到很高质量的渲染结果，但也非常耗时。通常用于离线制作动画电影。
光线追踪的**理论基础：光路是可逆的**。一条从相机发出的光线如果能够到达光源，则光源发出的光线也能沿着同一路径反向到达相机。因此，可以从相机原点出发，穿过成像平面上每一点发射一条射线，追踪该射线每一次与物体相交后发生发射或折射，直至其到达光源或终止传播。上述过程可以利用递归的方式实现，称为recursive (Whitted-style) ray tracing。这就是光线追踪的**核心思想：追踪从相机发出的光线**。

*（光线追踪剩余内容和个人研究方向关联性暂时不强，后续需要时补充）*。


# 6. Animation 动画

一般来说，动画和渲染是分离的两个步骤：先对几何模型施加动态效果，再逐帧地渲染场景。
接下来介绍实现动画的几种常见方法。

## 6.1 Keyframe animation 关键帧动画

由设计师手工设计出关键帧上的模型，关键帧之间的帧上的模型则通过插值的方法得到。
注意：
1. 插值的方法不一定是线性插值，通常是更复杂的插值方法。
2. 插值并不是针对图像，而是针对几何模型。如前所述，通过关键帧动画方法得到每帧的模型后，再通过渲染得到图像。

## 6.2 Physical simulation 物理模拟（仿真）

这类方法以牛顿运动定律 $F = ma$ 为基本思想，对场景中的物体模型赋予质量，并定义每个物体受到的作用力，从而得到物体在每一时刻的加速度，进而模拟出物体在每一时刻的速度和位姿。实际应用中，物体的受力可能十分复杂，但只要定义清楚、合理，都能得到不错的动画效果。

### 6.2.1 Mass-string system 质点弹簧系统

一种简单而有用的系统，包括一根弹簧和被弹簧连接的两个质点。系统中的作用力包括弹簧上的弹力和阻力（用来产生能量损耗，避免弹簧在模拟中无休止地振动）。
通过不同方式组合多个质点弹簧系统，可以模拟出绳子、毛巾、衣物等的运动。

### 6.2.2 Particle system 粒子系统

通过生成大量的粒子并定义粒子间的作用力，可以模拟出烟雾、流体等效果。通常粒子数量越多，模拟效果越逼真，相应地会增加计算开销。为此，一些加速方法被设计出来，用以高效地为每个粒子寻找邻近区域内的、相互作用力足够大的粒子。

#### Position-based method
这种方法没有显式的受力分析，常用于流体模拟。这种方法假设构成流体的粒子在任意区域内的密度趋向于保持某个稳定值，当某个区域粒子密度发生变化，所有粒子的运动都趋向于修正这种变化，使粒子密度恢复稳定值。基于上述思想，可以通过梯度下降的方式求解粒子的运动。

### 6.2.3 Single particle simulation 单粒子模拟

物理模拟一般包括两个步骤：第一步，定义物体受力模型；第二步，根据受力模型计算物体在每一时刻的位姿。前面两个小节介绍了两种常用的受力模型，本小节则针对第二步，简要介绍一种简单情况——计算单个粒子在速度场中的位移。同样的方法也可以用来计算单个粒子在加速度场中的速度。
问题设定如下：已知任意时刻粒子在速度场中任意位置的速度 $v(x, t)$ ，以及粒子的初始位置 $x_0$，求解粒子的位移轨迹 $x(t)$ .
这个问题本质上是求解常微分方程：
$\frac{dx}{dt} = \dot{x} = v(x,t), x(0) = x_0$ .

实际应用中，则一般采用数值解法。
最基本的解法是欧拉法：每次移动 $\Delta t$ 的时长，基于前一时刻的速度进行更新，即：
$x(t+ \Delta t) = x(t) + \Delta t \cdot \dot{x}(t)$ .
但是欧拉法稳定性比较差，数值误差不断累积，经常导致模拟结果严重偏离实际期望值。下面介绍一些增强稳定性的改进方法。

#### Modified Euler
改进欧拉法中，首先基于欧拉法计算终止点速度
$\dot{x}(t+ \Delta t) = \dot{x}(t) + \Delta t \cdot \ddot{x}(t)$ .
随后综合起点和终点的速度进行更新
$x(t+ \Delta t) = x(t) + \frac{\Delta t}{2} \cdot [\dot{x}(t) + \dot{x}(t+ \Delta t)]$ .

#### Midpoint
中点法中，首先基于欧拉法寻找中点
$x_{mid} = x(t) + \frac{\Delta t}{2} \cdot \dot{x}(t)$ .
随后基于中点的速度进行更新
$x(t+ \Delta t) = x(t) + \Delta t \cdot \dot{x}_{mid}$ .
类似于改进欧拉法，中点法可以认为是另一种综合起点和终点的速度进行更新的方法。

#### Adaptive step size
首先基于欧拉法计算 $x(t+ \Delta t)$ 和 $x(t+ \frac{\Delta t}{2})$ 。如果两者的差异大于设定的阈值，则认为 $\Delta t$ 的更新步长带来的误差过大，减小步长再次执行，直到差异小于阈值，则基于该步长进行更新。

#### Implicit Euler
隐欧拉法的核心思想是基于终点的速度更新
$x(t+ \Delta t) = x(t) + \Delta t \cdot \dot{x}(t + \Delta t)$ .
但无法直接求解，需要通过牛顿法等方法求解方程的根。隐欧拉法的结果通常非常稳定。

## 6.3 Kinematics 运动学

图形学中的运动学分为前向运动学 (Forward Kinematics, FK) 和逆运动学 (Inverse Kinematics, IK) ，都是针对通过关节点连接成的物体模型。在FK中，已知每个关节点的运动（主要是旋转）参数，计算物体的位姿；在IK中则相反，已知物体的位姿，推算每个关节点的运动参数。
IK的好处是便于控制，实现过程非常直接，缺点是动画设计师的工作变得繁琐；FK为动画设计师的工作提供了便利，但FK本身的计算是十分困难的，通常存在不唯一解，需要采用优化的方法进行计算。

## 6.4 Rigging

rigging这个词本身是（利用绳索）操纵的意思。在图形学中，rigging是指在物体模型上选择若干关键点，提前定义好关键点和物体模型上所有顶点（此处是针对用mesh表示的几何模型来说）之间的关联，随后通过少数关键点的运动，来达到驱动整个模型运动的目的。