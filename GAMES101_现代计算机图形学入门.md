# 0. 

该课程讲述了现代计算机图形学中的核心要素，[原课程](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)来自UC Santa Barbara闫令琪教授。
以下是个人理解的一条线索：
1. **Transformation & Rasterization**
哪些物体出现在图像上 —— 图像上出现的是什么？
2. **Shading**
物体以什么形式出现在图像上 —— 图像上为什么呈现这些颜色？


# 1. Transformation 变换

## 1.1 Basics

缩放、旋转等变换都可以用矩阵乘法表示，为了使平移变换也能用矩阵乘法表示，引入齐次坐标：
对于二维空间，(x, y, 1)表示其中的点，(ax, ay, a)（对任意a>0）表示的是同一个点(x, y, 1)；(x, y, 0)表示其中的向量（其他维度的空间也一样）。
可以验证，根据上述定义：
* 点 - 点 = 向量
* 向量 +/- 向量 = 向量
* 点 +/- 向量 = 点
......

## 1.2 Transformation in Graphics

### Model transformation 模型变换

对三维空间中的物体进行缩放、旋转、平移等各种变换。

### View transformation 视图变换

定义相机坐标系，将世界坐标系中的物体变换到相机坐标系中。

### Projection transformation 投影变换

#### Orthogonal projection 正交投影
1. **物理意义**
相当于直接保留三维物体在相机坐标系中的(x, y)坐标到成像平面上，去掉z轴；无”近大远小“现像。
2. **操作方法** 
将三维空间中的长方体区域变换到$[-1, 1]^3$的标准立方体区域。

#### Perspective projection 透视投影
1. **物理意义**
体现了”近大远小“的原则，投影结果更具有真实感。
2. **操作方法**
先将三维空间中的四棱台区域（图形学管线中称为frustum）变换到长方体区域，再应用正交投影变换到$[-1, 1]^3$的标准立方体区域。


# 2. Rasterization 光栅化

光栅化就是将成像平面上的物体以离散化的像素表示。
三角形具有”同一个三角形内部和边缘上的点都位于同一平面“的优良性质，因此在图形学应用中常被视为基本单元。我们也以三角形为例，考虑光栅化中的问题。

## 2.1 Rasterizing a Triangle

在成像时每个像素覆盖的方格区域只能显示一种颜色，通常由像素方格的中心点位置决定。
因此在光栅化一个三角形的过程中，核心步骤就是判断每个像素方格的中心位置是否在三角形内。

### Inside function

**点O在三角形ABC内部的条件**
向量组$(OB \times AB, OC \times BC, OA \times CA)$（$\times$表示向量叉积）具有相同的方向（三角形边缘上的情况可根据实际应用自行定义）。

### Anti-aliasing

由于成像分辨率不足导致的锯齿化现象称为aliasing，即为信号理论中采样频率不足导致的信号失真。
根据信号理论，对信号先进行低通滤波（模糊）后采样可以解决该问题。这是因为时域上的采样对应频域上的频谱复制，时域上的采样频率越低则频域上频谱复制的越密集，产生交叠导致信号失真；进行低通滤波后，频谱宽度变窄，经过密集复制后交叠的概率降低了。

#### Multi-sample anti-aliasing (MSAA)
**1. 操作方法**
对每个像素方格，取其中（均匀分布）的若干个采样点，判断每个点是否位于三角形内部，将这些结果取平均值作为该像素点位于三角形内部的置信度。
**2. 物理意义**
个人理解，MSAA相当于对一个高分辨率的信号（由采样点构成）先做模糊（取均值），得到像素值（采样）。
其中采样的步骤是比较隐式的。

## 2.2 Rasterizing Objects

当有多个物体需要成像时，必须基于深度判断遮挡的情况，这个步骤称为深度测试。

### Z-Buffer 深度缓存算法

**1. 核心思想**
只考虑最前面的物体，因此不需要O(N log N)的排序，只需要一直保留最小值，复杂度为O(N)。
**2. 操作方法**
```
# 为每个像素点初始化一个（无穷大）的z值
Z[:] = inf
# 循环遍历每个三角形
for obj in objects:
    # 光栅化该三角形，因此循环遍历每个像素
    for p in P:
        if inside(p, obj):
            # 获取当前三角形在该点的深度值，判断深度缓存是否需要更新
            Z[p] = min(Z[p], obj[p]['z'])
 return Z
```


# 3. Shading 着色

## 3.1 Blinn-Phong Reflectance Model

以物体表面的shading point为基本单元，考虑从该点反射出的光线情况，有以下几个要素：
* **表面法向量n**（我们认为shading point是一小片有面积的单位区域）
* **光线入射方向l**
* **观察方向v**
（上述方向均为单位向量）

通常反射出的光线由漫反射项、高光项和环境光项三部分组成：
$L = L_d + L_s + L_a$

### Diffuse (Lambertian) term 漫反射项

#### 到达Shading point的光
空间中一个点光源向四面八方发射出的光线，可以认为在每一时刻都到达一个以点光源为中心的球面。
因此，球面上某点接收到的光照强度与球面积成反比。
半径为单位长度的球面上，每个点接收到光照强度为I，那么距离光源为r的shading point接收到光照强度为$I/r^2$ .

#### Shading point吸收到的光
$L = (I/r^2) max(0, n \cdot l)$ .
入射方向和表面法向量夹角越小，吸收到的光越多；光线垂直入射时能被最大程度吸收

#### Shading point反射的光
物体表面会基于自身颜色，反射一部分光，吸收掉另一部分
$L_d = K_d (I/r^2) max(0, n \cdot l)$ .
在漫反射情况下，shading point向各个方向反射出的光照是一样的，因此与观察方向无关。对同一个点，从任意视角观察到的颜色都是一样的。

### Specular term 高光项

在这部分将模型简化，只考虑到达shading point的光和shading point反射的光，吸收的情况省略掉（实际与前面漫反射项一致）。
高光项近似于镜面反射，当观察方向与镜面反射方向接近时容易看到高光
但是，给定光线入射方向和法线方向，计算反射方向的表达是比较繁琐的；相比之下，计算入射方向与观察方向的角平分线方向（半程向量），并考察它与法线方向的接近程度也能起到相同的作用，且更容易计算：
**半程向量** $h = \frac{l + v}{\| l + v \|}$ .
从观察方向v看到的高光项亮度为
$L_s = K_s (I/r^2) max(0, n \cdot h)^p$ .
指数p越大，高光项越接近于严格的镜面反射。

### Ambient term 环境光项

一个大胆的假设：对任意shading point从任意方向观察到的环境光项是相同的！
$L_a = K_a I_a$ .

## 3.2 Shading Frequency

### Flat shading

对于每一个（三角形）平面，基于该平面的法线方向计算反射光，整个平面渲染成同一种亮度。

### Gouraud shading

对于每一个（三角形）平面的各个顶点，基于顶点的法线方向计算顶点处的反射光，然后基于顶点亮度插值出平面内某个点（或fragment）的渲染亮度。
其中，顶点的法线方向可以通过对其邻接的各个平面法线方向进行加权平均得到。

### Phong shading

对于每一个（三角形）平面，基于顶点的法线方向出指出平面内某个点的法线方向，然后基于该点的法线方向计算该点（或fragment）的渲染亮度。

## 3.3 Graphics Pipeline 实时渲染管线

基本的实时渲染管线由以下步骤构成：
1. 经过 model - view - projection 变换将三角形的顶点投影到屏幕上
2. 三角形光栅化（包括 anti-aliasing 和 Z-buffer）
3. 三角形着色

其中，对每个点（或fragment）进行着色处理的代码被称为shader。

## 3.4 Interpolation 内插

内插是计算机图形学中常用的重要基础技术，用于从索引为离散值的计算机存储数据中查询任意连续值索引的数据。

### Baycentric coordinates 重心坐标

在一条线段上，给定两个端点的（属性）值，内插得到线段上任意一点的（属性）值是很容易的。接下来我们考虑平面上，特别地，一个三角形内部任意点的（属性）值如何通过内插得到。

空间中一个三角形三个顶点坐标为A, B, C,, 三角形所在平面上任意一点v的坐标可表示为：
$v = \alpha A + \beta B + \gamma C$ .
其中，$\alpha + \beta + \gamma = 1$ .
这一约束确保了点v在三角形所在平面上。
特别地，当点v在三角形内部时，$\alpha, \beta, \gamma \geq 0$
$<\alpha, \beta, \gamma>$ 被称为点v的重心坐标。
至此，给定三个顶点的任意属性值f，利用重心坐标即可内插出点v的属性值f：
$f_v = \alpha f_A + \beta f_B + \gamma f_C$ .
这种内插方式可用于各种属性值，包括前面Gouraud shading中的渲染亮度、Phong shading中的法线方向，以及后面要讲的纹理映射。

## 3.5 Texture Mapping 纹理映射

纹理可以认为是一张二维图像；空间中的三维物体的表面也是二维的。
因此，可以建立物体表面上的点到纹理图上的点的映射关系，称为纹理映射。
例如，根据定义好的纹理映射关系，物体表面上的点a映射到纹理图上的点<u, v>，那么纹理图上点<u, v>的纹理颜色T(u,v)即可用来贴到点a上（通常用作着色中漫反射项的$K_d$)，这一过程称为纹理查询 (texture query)。
这样的纹理映射关系，通常需要CG艺术家精心设计。

### 点查询

假设纹理图像中每个像素的坐标都是整数，但纹理查询得到的点<u, v>未必是整数，此时可通过（双线性）内插的方法得到T(u,v)。

距离相机较近的物体，经过光栅化后在屏幕上一个像素方格的区域映射到纹理图像上，通常是不足一个像素方格的极小区域；换句话说，此时纹理图像分辨率偏低。这种情况可以直接通过双线性插值取近似值，作为纹理查询的结果。

### 范围查询

而距离相机较远的物体，经过光栅化后在屏幕上一个像素方格的区域映射到纹理图像上，通常会覆盖多个像素放个连成的一大片区域；换句话说，此时纹理图像分辨率偏高。这种情况下，如果仍然基于点进行查询，就会出现欠采样导致的aliasing（与光栅化中的锯齿现象原理相同）。

可以在屏幕上的每个像素方格内增加采样点（提高采样频率）以去除aliasing，但这样开销太大。更好的方法是用范围查询替代点查询，直接查询被覆盖的一大片纹理图像区域的像素均值。

#### Mip-Map

Mip-Map是一种计算和存储开销都很低的范围查询方式。具体做法是提前对原始的纹理图像取 $2 \times, 4 \times, ...$ 的下采样，得到多层的Mip-Map（类似于计算机视觉中的图像金字塔）。
存储所有这些下采样的图像**只带来 $\frac{1}{3}$ 的额外存储开销**。

**如何计算覆盖区域的范围？**
可以将待查询的屏幕像素方格及其周围4个方格映射到纹理图像上，从而近似计算 $(<\frac{du}{dx}, \frac{dv}{dx}>, <\frac{du}{dy}, \frac{dv}{dy}>)$ .
根据覆盖区域的范围大小，从Mip-Map对应的层取值即可。
可以看出，**Mip-Map只适合查询近似于正方形的区域**。

#### Variants of Mip-Map

* **Trilinear sampling（三线性插值）：**
如果覆盖区域的范围大小无法刚好对应到Mip-Map的整数层，可以先从前后两层分别取值，然后插值。三线性插值使画面颜色具备更好的连续性。

* **Anisotropic filtering（各向异性过滤）：**
用于解决Mip-Map只适合查询正方形区域的问题。具体做法是在Mip-Map基础上引入单独对长/宽进行下采样的图像，以查询不同长宽比的矩形区域。

